<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>Игра жизнь - начало</title>
    <script type="text/javascript" src="libs/jquery-1.9.0.js"></script>
    <script type="text/javascript" src="libs/three.js"></script>
    <script type="text/javascript" src="libs/stats.min.js"></script>
    <script type="text/javascript" src="libs/dat.gui.js"></script>
    <style>
        body{
            /* set margin to 0 and overflow to hidden,
            to use the complete page */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

    <!--<h1>Игра жизнь - начало</h1>-->
    <!--<p>Это будет игра жизнь</p>-->
	<p>for test evgeni</p>
    <!-- Div which will hold the Output -->
    <div id="WebGL-output"></div>
    <div id="Stats-output"></div>
    <!-- Javascript code that runs our Three.js examples -->
    <script type="text/javascript">
        // once everything is loaded, we run our Three.js stuff.
        (function($){
            $(document).ready(function () {
                function initStats() {
                    var stats = new Stats();
                    stats.setMode(0);
                    stats.domElement.style.position = 'absolute';
                    stats.domElement.style.left = '0px';
                    stats.domElement.style.top = '0px';
                    $("#Stats-output").append( stats.domElement );
                    return stats;
                }

                var stats = initStats();

                //gui - interface control
                var controls = new function() {
                    this.addCube = function () {

                        //AJAX запрос к серверу (получает координаты и размер куба)
                        $.post('http://localhost:8888/set_cell', {}, function(){  // загрузку JSON данных с сервера

                            var cubeSize = cube[0];
                            var position_x = cube[1];
                            var position_y = cube[2];
                            var position_z = cube[3];
                        });

                        //добавляет куб на сцену по полученным с сервера данным
                        var cubeSize = cubeSize;
                        var cubeGeometry = new THREE.CubeGeometry(cubeSize,cubeSize,cubeSize);
                        var cubeMaterial = new THREE.MeshLambertMaterial({color:  Math.random() * 0xffffff });
                        var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                        cube.castShadow = true;
                        cube.name = "cube-" + scene.children.length;


                        // position the cube randomly in the scene
                        cube.position.x = position_x;
                        cube.position.y = position_y;
                        cube.position.z =  position_z;

                        // add the cube to the scene
                        scene.add(cube);
                    }
                }

                var gui = new dat.GUI();

                gui.add(controls, 'addCube');

                var scene = new THREE.Scene();
                var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                var renderer = new THREE.WebGLRenderer();
                renderer.setClearColorHex(0xEEEEEE);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMapEnabled = true;

                var spotLight = new THREE.SpotLight( 0xffffff );
                spotLight.position.set( -40, 60, -10 );
                spotLight.castShadow = true;
                scene.add( spotLight );

                var axes = new THREE.AxisHelper( 20 );
                scene.add(axes);

                var planeGeometry = new THREE.PlaneGeometry(60,60,1,1);
                var planeMaterial = new THREE.MeshLambertMaterial({color: 0xcccccc});
                var plane = new THREE.Mesh(planeGeometry,planeMaterial);
                plane.receiveShadow = true;
                plane.rotation.x=-0.5*Math.PI;
                plane.position.x = 0;
                plane.position.y = 0;
                plane.position.z = 0;
                scene.add(plane);

                var cubeGeometry = new THREE.CubeGeometry(2,1,2);
                var cubeMaterial = new THREE.MeshLambertMaterial({color: 0xff0000});

                var fields = [];
				//THREE.vector[0,0,0],[-1,0,0],[0,0,-1],[1,0,0],[0,0,1]
                var cube = [];
                var x_count = 10;
                var y_count = 10;



                for (var i = 0; i < x_count; i++){
                    for (var j = 0; j < y_count; j++){
                        var item = [i * x_count + j];
                        cube[item] = new THREE.Mesh(cubeGeometry, cubeMaterial);
                        cube[item].castShadow = true;
                        cube[item].position.x = i * 3;
                        cube[item].position.y = 0;
                        cube[item].position.z = j * -3 ;
                        scene.add(cube[item]);
                    }
                }


//                var sphereGeometry = new THREE.SphereGeometry(4,20,20);
//                var sphereMaterial = new THREE.MeshLambertMaterial({color: 0x7777ff});
//                var sphere = new THREE.Mesh(sphereGeometry,sphereMaterial);
//                sphere.castShadow = true;
//                sphere.position.x = 20;
//                sphere.position.y = 4;
//                sphere.position.z = 2;
//                scene.add(sphere);

                camera.position.x = 0;
                camera.position.y = 50;
                camera.position.z = 0;
                camera.lookAt(scene.position);

                $("#WebGL-output").append(renderer.domElement);
                renderScene();

//                var step=0;

                function renderScene() {
                    stats.update();

//                    cube.rotation.x += 0.02;
//                    cube.rotation.y += 0.02;
//                    cube.rotation.z += 0.02;

//                    step+=0.04;
//                    sphere.position.x = 20+( 10*(Math.cos(step)));
//                    sphere.position.y = 2 +( 10*Math.abs(Math.sin(step)));

                    requestAnimationFrame(renderScene)
                    renderer.render(scene, camera);
                }


            });
        })(jQuery);

    </script>
</body>
</html>
<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>Игра жизнь - начало</title>
    <script type="text/javascript" src="libs/jquery-1.9.0.js"></script>
    <script type="text/javascript" src="libs/three.js"></script>
    <script type="text/javascript" src="libs/stats.min.js"></script>
    <script type="text/javascript" src="libs/dat.gui.js"></script>
    <script type="text/javascript" src="libs/Detector.js"></script>
    <script type="text/javascript" src="libs/OrbitControls.js"></script>
    <script type="text/javascript" src="libs/THREEx.KeyboardState.js"></script>
    <script type="text/javascript" src="libs/THREEx.FullScreen.js"></script>
    <script type="text/javascript" src="libs/THREEx.WindowResize.js"></script>
    <style>
        body{
            /* set margin to 0 and overflow to hidden,
            to use the complete page */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

    <!--<h1>Игра жизнь - начало</h1>-->
    <!--<p>Это будет игра жизнь</p>-->
	<p>for test evgeni</p>
    <!-- Div which will hold the Output -->
    <div id="WebGL-output"></div>
    <div id="Stats-output"></div>
    <!-- Javascript code that runs our Three.js examples -->
    <script type="text/javascript">
        // once everything is loaded, we run our Three.js stuff.
        (function($){
            $(document).ready(function () {

                var container, scene, camera, renderer, controls, stats;
                var projector, mouse = { x: 0, y: 0 }, INTERSECTED;
                var keyboard = new THREEx.KeyboardState();
                var clock = new THREE.Clock();

                init();
                animate();


                function init() {
                    function initStats() {
                        var stats = new Stats();
                        stats.setMode(0);
                        stats.domElement.style.position = 'absolute';
                        stats.domElement.style.left = '0px';
                        stats.domElement.style.top = '0px';
                        $("#Stats-output").append( stats.domElement );
                        return stats;
                    }

                    var stats = initStats();

                    //gui - interface control
//                    var gui_controls = new function() {
//                        this.addCube = function () {
//
//                            //AJAX запрос к серверу (получает координаты и размер куба)
//                            $.post('http://localhost:8888/set_cell', {}, function(){  // загрузку JSON данных с сервера
//
//                                var cubeSize = cube[0];
//                                var position_x = cube[1];
//                                var position_y = cube[2];
//                                var position_z = cube[3];
//                            });
//
//                            //добавляет куб на сцену по полученным с сервера данным
//                            var cubeSize = cubeSize;
//                            var cubeGeometry = new THREE.CubeGeometry(cubeSize,cubeSize,cubeSize);
//                            var cubeMaterial = new THREE.MeshLambertMaterial({color:  Math.random() * 0xffffff });
//                            var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
//                            cube.castShadow = true;
//                            cube.name = "cube-" + scene.children.length;
//
//
//                            // position the cube randomly in the scene
//                            cube.position.x = position_x;
//                            cube.position.y = position_y;
//                            cube.position.z =  position_z;
//
//                            // add the cube to the scene
//                            scene.add(cube);
//                        }
//                    }


//                    var gui = new dat.GUI();

//                    gui.add(controls, 'addCube');

                    scene = new THREE.Scene();

                    // CAMERA
                    var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
                    var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
                    camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
                    scene.add(camera);
                    camera.position.set(0,150,400);
                    camera.lookAt(scene.position);

//                var renderer = new THREE.WebGLRenderer();

                    // RENDERER
                    if ( Detector.webgl )
                        renderer = new THREE.WebGLRenderer( {antialias:true} );
                    else
                        renderer = new THREE.CanvasRenderer();

                    renderer.setClearColorHex(0xEEEEEE);
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    renderer.shadowMapEnabled = true;
                    $("#WebGL-output").append(renderer.domElement);

                    // EVENTS
                    THREEx.WindowResize(renderer, camera);
                    THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });

                    // CONTROLS
                    controls = new THREE.OrbitControls( camera, renderer.domElement );

                    // SKYBOX/FOG
                    var skyBoxGeometry = new THREE.CubeGeometry( 10000, 10000, 10000 );
                    var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0x9999ff, side: THREE.BackSide } );
                    var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
                    scene.add(skyBox);

                    var spotLight = new THREE.SpotLight( 0xffffff );
                    spotLight.position.set( -40, 60, -10 );
                    spotLight.castShadow = true;
                    scene.add( spotLight );

                    var axes = new THREE.AxisHelper( 20 );
                    scene.add(axes);

                    var planeGeometry = new THREE.PlaneGeometry(60,60,1,1);
                    var planeMaterial = new THREE.MeshLambertMaterial({color: 0xcccccc});
                    var plane = new THREE.Mesh(planeGeometry,planeMaterial);
                    plane.receiveShadow = true;
                    plane.rotation.x=-0.5*Math.PI;
                    plane.position.x = 0;
                    plane.position.y = 0;
                    plane.position.z = 0;
                    scene.add(plane);

                    var field = [];
                    var x_count = 10;
                    var y_count = 10;
                    var radius = 6.5;

                    for (var i = 0; i < x_count; i++){
                        for (var j = 0; j < y_count; j++){
                            var item = [i * x_count + j];
                            field[item] = new THREE.Mesh(new THREE.CylinderGeometry(3, 4, 1, 6));
                            if ( j % 2 ) field[item].position.x = i * radius + radius/2 + 1;
                            else field[item].position.x = i * radius + 1;

                            field[item].position.y = 1;
                            field[item].position.z = j * - radius + 1;
                            scene.add(field[item]);
                        }
                    }

                    // initialize object to perform world/screen calculations
                    projector = new THREE.Projector();

                    // when the mouse moves, call the given function
                    document.addEventListener( 'mousemove', onDocumentMouseMove, false );
                }

                function onDocumentMouseMove( event )
                {
                    // the following line would stop any other event handler from firing
                    // (such as the mouse's TrackballControls)
                    // event.preventDefault();

                    // update the mouse variable
                    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                    mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                }

                function animate()
                {
                    requestAnimationFrame( animate );
                    render();
                    update();
                }


                function update()
                {
                    // find intersections

                    // create a Ray with origin at the mouse position
                    //   and direction into the scene (camera direction)
                    var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
                    projector.unprojectVector( vector, camera );
                    var ray = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

                    // create an array containing all objects in the scene with which the ray intersects
                    var intersects = ray.intersectObjects( scene.children );

                    // INTERSECTED = the object in the scene currently closest to the camera
                    //		and intersected by the Ray projected from the mouse position

                    // if there is one (or more) intersections
                    if ( intersects.length > 0 )
                    {
                        // if the closest object intersected is not the currently stored intersection object
                        if ( intersects[ 0 ].object != INTERSECTED )
                        {
                            // restore previous intersection object (if it exists) to its original color
                            if ( INTERSECTED )
                                INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
                            // store reference to closest object as current intersection object
                            INTERSECTED = intersects[ 0 ].object;
                            // store color of closest object (for later restoration)
                            INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
                            // set a new color for closest object
                            INTERSECTED.material.color.setHex( 0xffff00 );
                        }
                    }
                    else // there are no intersections
                    {
                        // restore previous intersection object (if it exists) to its original color
                        if ( INTERSECTED )
                            INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
                        // remove previous intersection object reference
                        //     by setting current intersection object to "nothing"
                        INTERSECTED = null;
                    }


                    if ( keyboard.pressed("z") )
                    {
                        // do something
                    }

                    controls.update();
                    stats.update();
                }

                function render()
                {
                    renderer.render( scene, camera );
                }



                //THREE.vector[0,0,0],[-1,0,0],[0,0,-1],[1,0,0],[0,0,1]
//                var cube = [];




//                for (var i = 0; i < x_count; i++){
//                    for (var j = 0; j < y_count; j++){
//                        var item = [i * x_count + j];
//                        cube[item] = new THREE.Mesh(cubeGeometry, cubeMaterial);
//                        cube[item].castShadow = true;
//                        cube[item].position.x = i * 3;
//                        cube[item].position.y = 0;
//                        cube[item].position.z = j * -3 ;
//                        scene.add(cube[item]);
//                    }
//                }


//                var sphereGeometry = new THREE.SphereGeometry(4,20,20);
//                var sphereMaterial = new THREE.MeshLambertMaterial({color: 0x7777ff});
//                var sphere = new THREE.Mesh(sphereGeometry,sphereMaterial);
//                sphere.castShadow = true;
//                sphere.position.x = 20;
//                sphere.position.y = 4;
//                sphere.position.z = 2;
//                scene.add(sphere);



//                renderScene();

//                var step=0;

//                function renderScene() {
//                    stats.update();

//                    cube.rotation.x += 0.02;
//                    cube.rotation.y += 0.02;
//                    cube.rotation.z += 0.02;

//                    step+=0.04;
//                    sphere.position.x = 20+( 10*(Math.cos(step)));
//                    sphere.position.y = 2 +( 10*Math.abs(Math.sin(step)));

//                    requestAnimationFrame(renderScene)
//                    renderer.render(scene, camera);
//                }


            });
        })(jQuery);

    </script>
</body>
</html>